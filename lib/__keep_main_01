import 'dart:convert';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart' show rootBundle;

/// ==============================
/// GeoJSON 読み込み＆判定（ライブラリ無し）
/// - Polygon / MultiPolygon に対応
/// - 穴（内側リング）にも対応
/// - BBOX で粗判定 → ポリゴン判定
/// ==============================

/// 読み込んだ境界データ（複数ポリゴン＋BBOX）
class GeoBoundary {
  /// MultiPolygon を展開した「ポリゴン（外周＋穴）」の配列
  /// 各 Polygon は `List<List<List<double>>>` = [rings][points][lng/lat]
  /// - rings[0]: 外周
  /// - rings[1..]: 穴
  final List<List<List<List<double>>>> polygons;

  /// [minLng, minLat, maxLng, maxLat]
  final List<double> bbox;

  GeoBoundary({required this.polygons, required this.bbox});
}

late GeoBoundary _tokyo;

/// アセットの GeoJSON を読み込む
Future<void> loadTokyoBoundary({String assetPath = 'assets/tokyo_mainland.geojson'}) async {
  final text = await rootBundle.loadString(assetPath);
  final data = jsonDecode(text);

  // geometry を取り出す（Feature / FeatureCollection / 直接 Polygon/MultiPolygon を許容）
  Map<String, dynamic>? geom;
  if (data['type'] == 'Feature') {
    geom = data['geometry'];
  } else if (data['type'] == 'FeatureCollection') {
    final features = (data['features'] as List);
    if (features.isEmpty) {
      throw Exception('FeatureCollection が空です');
    }
    // 通常 dissolve 済みなら最初の要素に境界が入っている想定
    geom = Map<String, dynamic>.from(features.first['geometry'] as Map);
  } else if (data['type'] == 'Polygon' || data['type'] == 'MultiPolygon') {
    geom = Map<String, dynamic>.from(data as Map);
  } else {
    throw Exception('未対応の GeoJSON type: ${data['type']}');
  }

  if (geom == null || geom['type'] == null) {
    throw Exception('geometry が見つかりません');
  }

  // Polygon / MultiPolygon を polygons（統一形式）へ
  final type = geom['type'] as String;
  final List<List<List<List<double>>>> polygons = [];
  if (type == 'Polygon') {
    // coordinates: [rings][points][2]
    final coords = (geom['coordinates'] as List)
        .map((ring) => (ring as List).map((pt) => (pt as List).map((n) => (n as num).toDouble()).toList()).toList())
        .toList();
    polygons.add(coords);
  } else if (type == 'MultiPolygon') {
    // coordinates: [polygons][rings][points][2]
    final mcoords = (geom['coordinates'] as List)
        .map(
          (poly) => (poly as List)
              .map(
                (ring) => (ring as List).map((pt) => (pt as List).map((n) => (n as num).toDouble()).toList()).toList(),
              )
              .toList(),
        )
        .toList();
    polygons.addAll(mcoords);
  } else {
    throw Exception('未対応の geometry.type: $type');
  }

  // BBOX を計算
  final bbox = _computeBbox(polygons);

  _tokyo = GeoBoundary(polygons: polygons, bbox: bbox);
}

/// BBOX 計算 [minLng, minLat, maxLng, maxLat]
List<double> _computeBbox(List<List<List<List<double>>>> polygons) {
  double minLng = double.infinity, minLat = double.infinity;
  double maxLng = -double.infinity, maxLat = -double.infinity;

  for (final poly in polygons) {
    for (final ring in poly) {
      for (final p in ring) {
        final lng = p[0], lat = p[1];
        if (lng < minLng) minLng = lng;
        if (lng > maxLng) maxLng = lng;
        if (lat < minLat) minLat = lat;
        if (lat > maxLat) maxLat = lat;
      }
    }
  }
  return [minLng, minLat, maxLng, maxLat];
}

/// 点がポリゴン（外周＋穴）内か
/// polygon = [rings][points][lng/lat]（rings[0]=外周, rings[1..]=穴）
bool _pointInPolygon(double lat, double lng, List<List<List<double>>> polygon) {
  if (polygon.isEmpty) return false;

  // 1) 外周内判定
  final outer = polygon.first;
  if (!_pointInRing(lat, lng, outer)) return false;

  // 2) 穴に入っていないか
  for (int i = 1; i < polygon.length; i++) {
    if (_pointInRing(lat, lng, polygon[i])) {
      return false; // 穴の中 → 外扱い
    }
  }
  return true;
}

/// 点がリング内か（レイキャスティング）
/// ring = [points][lng/lat]
bool _pointInRing(double lat, double lng, List<List<double>> ring) {
  int cnt = 0;
  final int n = ring.length;
  for (int i = 0, j = n - 1; i < n; j = i++) {
    final xi = ring[i][0], yi = ring[i][1];
    final xj = ring[j][0], yj = ring[j][1];

    final intersect =
        ((yi > lat) != (yj > lat)) && (lng < (xj - xi) * (lat - yi) / ((yj - yi) == 0 ? 1e-12 : (yj - yi)) + xi);
    if (intersect) cnt++;
  }
  return (cnt % 2 == 1);
}

/// まずは BBOX で粗判定 → 通れば各ポリゴンで厳密判定
bool isInTokyo(double lat, double lng) {
  final b = _tokyo.bbox; // [minLng, minLat, maxLng, maxLat]
  if (!(lng >= b[0] && lng <= b[2] && lat >= b[1] && lat <= b[3])) {
    return false;
  }
  // どれかのポリゴンに入っていればOK
  for (final poly in _tokyo.polygons) {
    if (_pointInPolygon(lat, lng, poly)) return true;
  }
  return false;
}

/// ==============================
/// デモ UI
/// ==============================

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await loadTokyoBoundary(); // 読み込み後に起動
  runApp(const TokyoJudgeApp());
}

class TokyoJudgeApp extends StatelessWidget {
  const TokyoJudgeApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Tokyo In/Out Judge (No Lib)',
      theme: ThemeData(useMaterial3: true, colorSchemeSeed: const Color(0xFF5566EE)),
      home: const TokyoJudgePage(),
    );
  }
}

class TokyoJudgePage extends StatefulWidget {
  const TokyoJudgePage({super.key});

  @override
  State<TokyoJudgePage> createState() => _TokyoJudgePageState();
}

class _TokyoJudgePageState extends State<TokyoJudgePage> {
  // サンプル座標（必要に応じて差し替え）
  final List<_Place> _places = const [
    _Place('都庁(新宿)', 35.6895, 139.6917),
    _Place('東京駅', 35.6812, 139.7671),
    _Place('渋谷駅', 35.6580, 139.7017),
    _Place('奥多摩駅', 35.8092, 139.0961),
    _Place('横浜駅', 35.4656, 139.6227),
    _Place('大宮駅', 35.9069, 139.6237),
    _Place('成田空港', 35.7720, 140.3929),
  ];

  late final List<_PlaceJudge> _judged;

  @override
  void initState() {
    super.initState();
    _judged = _places.map((p) => _PlaceJudge(place: p, inTokyo: isInTokyo(p.lat, p.lng))).toList();
  }

  @override
  Widget build(BuildContext context) {
    final inCount = _judged.where((e) => e.inTokyo).length;
    final outCount = _judged.length - inCount;

    return Scaffold(
      appBar: AppBar(title: const Text('緯度経度の東京都内/外 判定デモ（ライブラリ無し）')),
      body: Column(
        children: [
          const SizedBox(height: 12),
          _SummaryRow(inCount: inCount, outCount: outCount, total: _judged.length),
          const Divider(height: 24),
          Expanded(
            child: ListView.separated(
              itemCount: _judged.length,
              separatorBuilder: (_, __) => const Divider(height: 1),
              itemBuilder: (context, index) {
                final item = _judged[index];
                final badgeColor = item.inTokyo ? Colors.green : Colors.orange;
                final badgeText = item.inTokyo ? '東京都内' : '東京都外';
                return ListTile(
                  title: Text(item.place.name),
                  subtitle: Text('lat: ${item.place.lat}, lng: ${item.place.lng}'),
                  trailing: Container(
                    padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 6),
                    decoration: BoxDecoration(
                      color: badgeColor.withOpacity(0.12),
                      border: Border.all(color: badgeColor),
                      borderRadius: BorderRadius.circular(20),
                    ),
                    child: Text(
                      badgeText,
                      style: TextStyle(color: badgeColor, fontWeight: FontWeight.bold),
                    ),
                  ),
                );
              },
            ),
          ),
          const SizedBox(height: 8),
          Padding(
            padding: const EdgeInsets.all(12.0),
            child: Text(
              'BBOX: ${_tokyo.bbox.map((e) => e.toStringAsFixed(5)).join(', ')}  [minLng, minLat, maxLng, maxLat]',
              style: const TextStyle(fontSize: 12),
            ),
          ),
          const SizedBox(height: 12),
        ],
      ),
    );
  }
}

class _Place {
  final String name;
  final double lat;
  final double lng;

  const _Place(this.name, this.lat, this.lng);
}

class _PlaceJudge {
  final _Place place;
  final bool inTokyo;

  const _PlaceJudge({required this.place, required this.inTokyo});
}

class _SummaryRow extends StatelessWidget {
  const _SummaryRow({required this.inCount, required this.outCount, required this.total});

  final int inCount;
  final int outCount;
  final int total;

  @override
  Widget build(BuildContext context) {
    return Wrap(
      spacing: 12,
      runSpacing: 8,
      alignment: WrapAlignment.center,
      children: [
        _ChipStat(label: '東京都内', value: inCount.toString()),
        _ChipStat(label: '東京都外', value: outCount.toString()),
        _ChipStat(label: '合計', value: total.toString()),
      ],
    );
  }
}

class _ChipStat extends StatelessWidget {
  const _ChipStat({required this.label, required this.value});

  final String label;
  final String value;

  @override
  Widget build(BuildContext context) {
    return Chip(label: Text('$label: $value'), padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 6));
  }
}
